---
title: 'Integrating Axite with Your Stack'
description: 'A guide to integrating Axite with popular agent frameworks, LLM providers, and infrastructure.'
author: axite_team
image: 2025-12-28-integrating-axite-with-your-stack/og.jpg
thumb: 2025-12-28-integrating-axite-with-your-stack/og.jpg
categories:
  - developers
tags:
  - integration
  - tutorial
  - mcp
date: '2025-12-28'
toc_depth: 3
---

Axite integrates with your existing agent infrastructure. This guide covers the most common integration patterns.

## MCP Integration

The Model Context Protocol (MCP) is the fastest way to integrate Axite. Point your MCP-compatible tools at the Axite gateway:

```json
{
  "mcpServers": {
    "filesystem": {
      "command": "npx",
      "args": ["-y", "@anthropic/mcp-server-filesystem", "/path/to/files"],
      "env": {
        "AXITE_GATEWAY": "https://gateway.axite.ai",
        "AXITE_API_KEY": "your-key"
      }
    }
  }
}
```

Every tool call now flows through Axite for policy evaluation.

## LangChain Integration

For LangChain applications, wrap your tools with the Axite middleware:

```python
from axite import AxiteMiddleware
from langchain.tools import Tool

# Original tool
search_tool = Tool(
    name="search",
    func=search_function,
    description="Search the web"
)

# Wrapped with Axite
axite = AxiteMiddleware(api_key="your-key")
governed_tool = axite.wrap(search_tool)

# Use in your chain
agent = create_agent(tools=[governed_tool])
```

## OpenAI Function Calling

Intercept function calls before execution:

```typescript
import { Axite } from '@axite/sdk'

const axite = new Axite({ apiKey: 'your-key' })

// Before executing a function call
const decision = await axite.evaluate({
  agent: 'my-agent',
  action: 'function_call',
  function: functionCall.name,
  arguments: functionCall.arguments
})

if (decision.allowed) {
  // Execute the function
  const result = await executeFunction(functionCall)
}
```

## Custom Agent Frameworks

For custom frameworks, use the Axite SDK directly:

```typescript
import { Axite } from '@axite/sdk'

const axite = new Axite({
  apiKey: process.env.AXITE_API_KEY,
  agentId: 'my-custom-agent'
})

// Before any action
async function executeAction(action: Action) {
  const decision = await axite.evaluate({
    action: action.type,
    params: action.params,
    context: action.context
  })

  if (!decision.allowed) {
    if (decision.requiresApproval) {
      await waitForApproval(decision.approvalId)
    } else {
      throw new Error(`Action denied: ${decision.reason}`)
    }
  }

  return performAction(action)
}
```

## Infrastructure Integration

### Kubernetes

Deploy Axite as a sidecar:

```yaml
containers:
  - name: agent
    image: your-agent:latest
  - name: axite-sidecar
    image: axite/sidecar:latest
    env:
      - name: AXITE_API_KEY
        valueFrom:
          secretKeyRef:
            name: axite-secrets
            key: api-key
```

### AWS Lambda

Use the Axite Lambda layer:

```yaml
functions:
  agent:
    handler: handler.main
    layers:
      - arn:aws:lambda:us-east-1:123456789:layer:axite:1
    environment:
      AXITE_API_KEY: ${ssm:/axite/api-key}
```

## Webhook Integration

Receive real-time notifications for policy decisions:

```typescript
// Configure webhook in Axite dashboard
// POST https://your-app.com/webhooks/axite

app.post('/webhooks/axite', (req, res) => {
  const event = req.body

  if (event.type === 'decision.denied') {
    alertSecurityTeam(event)
  }

  if (event.type === 'approval.requested') {
    notifyApprovers(event)
  }

  res.status(200).send('OK')
})
```

<Admonition type="note">
  Webhooks are signed with your webhook secret. Always verify signatures in production.
</Admonition>

## Next Steps

- [SDK Reference](/docs/sdk) - Complete API documentation
- [Policy Configuration](/docs/policies) - Set up governance rules
- [Dashboard Guide](/docs/dashboard) - Monitor your agents
