---
phase: 11-blog-compatibility
plan: 04
type: execute
wave: 2
depends_on: [11-01, 11-03]
files_modified:
  - apps/www/_blog/2026-01-20-introducing-axite.mdx
  - apps/www/_blog/2026-01-18-policy-enforcement-for-ai-agents.mdx
  - apps/www/_blog/2026-01-15-getting-started-with-axite-policies.mdx
  - apps/www/_blog/2026-01-12-identity-and-rbac-for-agent-systems.mdx
  - apps/www/_blog/2026-01-10-building-secure-agent-workflows.mdx
autonomous: true

must_haves:
  truths:
    - "5 new Axite blog posts exist in _blog directory"
    - "Posts use valid MDX syntax (JSX-compliant tags)"
    - "Posts reference axite_team author"
    - "Posts have valid frontmatter with all required fields"
    - "Posts use existing categories (product, developers, engineering)"
    - "Posts have recent dates (January 2026)"
  artifacts:
    - path: "apps/www/_blog/2026-01-20-introducing-axite.mdx"
      provides: "Introduction post about Axite platform"
      contains: "Agent Governance Platform"
    - path: "apps/www/_blog/2026-01-18-policy-enforcement-for-ai-agents.mdx"
      provides: "Post about policy enforcement pillar"
      contains: "policy"
    - path: "apps/www/_blog/2026-01-15-getting-started-with-axite-policies.mdx"
      provides: "Developer guide for policies"
      contains: "getting started"
    - path: "apps/www/_blog/2026-01-12-identity-and-rbac-for-agent-systems.mdx"
      provides: "Post about identity/RBAC pillar"
      contains: "RBAC"
    - path: "apps/www/_blog/2026-01-10-building-secure-agent-workflows.mdx"
      provides: "Engineering post about secure workflows"
      contains: "workflow"
---

<objective>
Create the first 5 Axite placeholder blog posts covering overview and policy pillars.

Purpose: Populate the blog with Axite-focused content demonstrating the blog works
Output: 5 MDX blog posts with proper frontmatter and Axite content
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/phases/11-blog-compatibility/11-CONTEXT.md
@.planning/phases/11-blog-compatibility/11-RESEARCH.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create "Introducing Axite" post</name>
  <files>apps/www/_blog/2026-01-20-introducing-axite.mdx</files>
  <action>
Create the flagship introduction blog post at apps/www/_blog/2026-01-20-introducing-axite.mdx:

```mdx
---
title: 'Introducing Axite: The Agent Governance Platform'
description: 'Meet Axite - the control plane for AI agent actions. Ship agents your security team can approve.'
author: axite_team
image: axite/placeholder-og.png
thumb: axite/placeholder-thumb.png
categories:
  - product
tags:
  - governance
  - agents
  - launch
date: '2026-01-20'
toc_depth: 3
---

AI agents are transforming how businesses operate. But as these autonomous systems take on more critical tasks, a fundamental question emerges: how do you maintain control without sacrificing the benefits of automation?

## The Agent Control Problem

Modern AI agents can read documents, execute code, send emails, and interact with external APIs. This power comes with risk. Without proper governance, agents can:

- Access data they should not see
- Take actions that violate compliance requirements
- Make decisions without proper oversight
- Leave no audit trail for security reviews

## Axite: Your Agent Governance Control Plane

Axite sits between your agents and the actions they want to take. Think of it as a policy enforcement gateway that ensures every agent action is authorized, logged, and traceable.

### Three Pillars of Agent Governance

**1. Enforceable Policy**

Define what agents can and cannot do with declarative policies. Allow, deny, or require human approval for any action - all enforced at the gateway level.

**2. Identity and Least Privilege**

RBAC for the agent era. Assign identities to agents, define roles, and ensure agents only have access to the tools and data they need.

**3. Audit-Grade Evidence**

Every decision is logged with full context. Decision traces show exactly why an action was allowed or denied, giving your security team complete visibility.

## Getting Started

Axite integrates with your existing agent infrastructure through our MCP gateway. Deploy in minutes, not months.

<Admonition type="note">
  Axite is currently in early access. Request access to try the sandbox.
</Admonition>

Visit our [quickstart guide](/docs/quickstart) to deploy your first policy, or [contact our team](/contact/sales) for a security review of your agent architecture.
```

Key requirements:
- JSX-compliant tags (self-closing where needed)
- Valid frontmatter with all required fields
- Uses axite_team author
- References placeholder images
- Covers all three pillars
  </action>
  <verify>
Run: `head -20 apps/www/_blog/2026-01-20-introducing-axite.mdx`
Verify: Frontmatter is valid with title, author, categories
Run: `grep "Agent Governance Platform" apps/www/_blog/2026-01-20-introducing-axite.mdx`
Verify: Title mentions Agent Governance Platform
  </verify>
  <done>Introduction post created</done>
</task>

<task type="auto">
  <name>Task 2: Create "Policy Enforcement" post</name>
  <files>apps/www/_blog/2026-01-18-policy-enforcement-for-ai-agents.mdx</files>
  <action>
Create the policy enforcement deep-dive at apps/www/_blog/2026-01-18-policy-enforcement-for-ai-agents.mdx:

```mdx
---
title: 'Policy Enforcement for AI Agents'
description: 'How Axite enforces allow, deny, and approval policies at the gateway level for complete agent control.'
author: axite_team
image: axite/placeholder-og.png
thumb: axite/placeholder-thumb.png
categories:
  - product
tags:
  - policy
  - governance
  - security
date: '2026-01-18'
toc_depth: 3
---

Policies are the foundation of agent governance. Without clear rules about what agents can and cannot do, organizations face unpredictable behavior and compliance risks.

## The Policy Problem

Traditional access control was designed for humans. Users authenticate, receive permissions, and make decisions within those boundaries. Agents operate differently - they make thousands of decisions autonomously, often in milliseconds.

This scale requires a new approach: declarative policies enforced at the gateway.

## Axite Policy Architecture

Axite policies follow a simple model:

```typescript
interface Policy {
  name: string
  description: string
  rules: Rule[]
  priority: number
}

interface Rule {
  action: 'allow' | 'deny' | 'require_approval'
  conditions: Condition[]
  tools?: string[]
  resources?: string[]
}
```

### Policy Evaluation

When an agent requests an action, Axite evaluates all applicable policies:

1. **Match** - Find policies that apply to this agent and action
2. **Evaluate** - Check conditions against the current context
3. **Decide** - Return allow, deny, or require approval
4. **Log** - Record the decision with full context

### Example: Data Access Policy

```typescript
const sensitiveDataPolicy = {
  name: 'sensitive-data-access',
  description: 'Restrict access to PII and financial data',
  rules: [
    {
      action: 'deny',
      conditions: [
        { field: 'data.classification', equals: 'pii' },
        { field: 'agent.role', notIn: ['compliance-agent', 'hr-agent'] }
      ]
    },
    {
      action: 'require_approval',
      conditions: [
        { field: 'data.classification', equals: 'financial' },
        { field: 'amount', greaterThan: 10000 }
      ]
    }
  ]
}
```

## Real-Time Enforcement

Policies are evaluated in real-time at the MCP gateway. There is no batch processing, no eventual consistency - every action is checked before execution.

<Admonition type="tip">
  Start with permissive policies and tighten over time. Axite's audit logs show exactly what actions agents are taking, helping you refine policies based on real behavior.
</Admonition>

## Next Steps

Learn how to [write your first policy](/docs/policies) or explore [identity and RBAC](/blog/identity-and-rbac-for-agent-systems) for the next layer of control.
```
  </action>
  <verify>
Run: `head -15 apps/www/_blog/2026-01-18-policy-enforcement-for-ai-agents.mdx`
Verify: Frontmatter is valid
Run: `grep "Policy Enforcement" apps/www/_blog/2026-01-18-policy-enforcement-for-ai-agents.mdx`
Verify: Title present
  </verify>
  <done>Policy enforcement post created</done>
</task>

<task type="auto">
  <name>Task 3: Create "Getting Started" developer guide</name>
  <files>apps/www/_blog/2026-01-15-getting-started-with-axite-policies.mdx</files>
  <action>
Create the developer getting started guide at apps/www/_blog/2026-01-15-getting-started-with-axite-policies.mdx:

```mdx
---
title: 'Getting Started with Axite Policies'
description: 'A step-by-step guide to deploying your first agent governance policy with Axite.'
author: axite_team
image: axite/placeholder-og.png
thumb: axite/placeholder-thumb.png
categories:
  - developers
tags:
  - tutorial
  - policy
  - quickstart
date: '2026-01-15'
toc_depth: 3
---

This guide walks you through deploying your first Axite policy in under 10 minutes.

## Prerequisites

- An Axite account (request access at [axite.ai](/contact/sales))
- An existing AI agent or MCP-compatible tool
- Basic familiarity with JSON or TypeScript

## Step 1: Connect Your Agent

First, point your agent to the Axite gateway. If you are using MCP tools, update your configuration:

```json
{
  "mcpServers": {
    "axite-gateway": {
      "url": "https://gateway.axite.ai",
      "apiKey": "your-api-key"
    }
  }
}
```

## Step 2: Define Your First Policy

Create a simple policy that requires approval for any external API calls:

```typescript
// policies/external-api-approval.ts
export const externalApiPolicy = {
  name: 'external-api-approval',
  description: 'Require approval for external API calls',
  rules: [
    {
      action: 'require_approval',
      conditions: [
        { field: 'tool.type', equals: 'http_request' },
        { field: 'request.url', notStartsWith: 'https://internal.' }
      ],
      approvers: ['security-team']
    }
  ]
}
```

## Step 3: Deploy the Policy

Use the Axite CLI to deploy:

```bash
axite policy deploy policies/external-api-approval.ts
```

Or deploy via the dashboard UI.

## Step 4: Test the Policy

Have your agent attempt an external API call. You should see:

1. The request appear in the Axite dashboard
2. An approval request sent to the security-team channel
3. The agent waiting for approval before proceeding

## Step 5: Review the Audit Log

Navigate to the Audit section in your dashboard. You will see:

- The original request
- The policy that matched
- The decision (require_approval)
- The approval status and approver

<Admonition type="note">
  All audit logs are retained for 90 days by default. Enterprise plans include custom retention periods.
</Admonition>

## What is Next?

- Explore [policy conditions](/docs/policies/conditions) for more complex rules
- Set up [identity and roles](/docs/identity) for your agents
- Configure [approval workflows](/docs/approvals) for your team

Need help? Join our community or contact support.
```
  </action>
  <verify>
Run: `head -15 apps/www/_blog/2026-01-15-getting-started-with-axite-policies.mdx`
Verify: Frontmatter is valid with developers category
Run: `grep "Getting Started" apps/www/_blog/2026-01-15-getting-started-with-axite-policies.mdx`
Verify: Title present
  </verify>
  <done>Getting started guide created</done>
</task>

<task type="auto">
  <name>Task 4: Create "Identity and RBAC" post</name>
  <files>apps/www/_blog/2026-01-12-identity-and-rbac-for-agent-systems.mdx</files>
  <action>
Create the identity/RBAC post at apps/www/_blog/2026-01-12-identity-and-rbac-for-agent-systems.mdx:

```mdx
---
title: 'Identity and RBAC for Agent Systems'
description: 'How to implement role-based access control for AI agents with Axite identity management.'
author: axite_team
image: axite/placeholder-og.png
thumb: axite/placeholder-thumb.png
categories:
  - product
tags:
  - identity
  - rbac
  - security
date: '2026-01-12'
toc_depth: 3
---

When you have dozens of agents running across your organization, the question "which agent did what?" becomes critical. Axite's identity system brings RBAC to the agent era.

## Why Agent Identity Matters

In traditional systems, every action traces back to a human user. With agents, this chain breaks. An agent might:

- Run under a service account with broad permissions
- Share credentials with other agents
- Have no clear ownership or accountability

Axite solves this with dedicated agent identities.

## The Axite Identity Model

Every agent in Axite has:

- **Identity** - A unique identifier and associated metadata
- **Roles** - Permissions defining what the agent can do
- **Scope** - Resources the agent can access

```typescript
interface AgentIdentity {
  id: string
  name: string
  description: string
  owner: string  // Human accountable for this agent
  roles: Role[]
  scopes: Scope[]
  metadata: Record<string, any>
}
```

## Implementing Least Privilege

The principle of least privilege states that agents should have only the permissions they need. Axite makes this practical:

### 1. Start with Zero Permissions

New agents have no permissions by default. Everything is denied until explicitly allowed.

### 2. Assign Purpose-Specific Roles

Create roles that match agent responsibilities:

```typescript
const customerSupportRole = {
  name: 'customer-support-agent',
  permissions: [
    'read:customer-tickets',
    'write:ticket-responses',
    'read:knowledge-base'
  ],
  restrictions: [
    'deny:customer-pii',
    'deny:billing-data'
  ]
}
```

### 3. Scope to Specific Resources

Limit agents to specific data partitions:

```typescript
const agentScope = {
  agentId: 'support-agent-1',
  resources: [
    { type: 'tickets', filter: { region: 'north-america' } },
    { type: 'knowledge', filter: { category: 'product-faq' } }
  ]
}
```

## Role Hierarchy

Axite supports role inheritance for managing complex permission structures:

```
admin-agent
├── supervisor-agent (inherits + additional permissions)
│   └── worker-agent (inherits + restricted)
```

## Auditing Identity

Every action logged in Axite includes the agent identity, making it easy to:

- Track which agent took an action
- Identify permission issues
- Audit compliance requirements

<Admonition type="tip">
  Use the identity dashboard to visualize agent permissions and identify over-privileged agents.
</Admonition>

## Getting Started

1. [Create your first agent identity](/docs/identity/create)
2. [Define custom roles](/docs/identity/roles)
3. [Set up scope restrictions](/docs/identity/scopes)
```
  </action>
  <verify>
Run: `head -15 apps/www/_blog/2026-01-12-identity-and-rbac-for-agent-systems.mdx`
Verify: Frontmatter is valid
Run: `grep "RBAC" apps/www/_blog/2026-01-12-identity-and-rbac-for-agent-systems.mdx`
Verify: RBAC mentioned in content
  </verify>
  <done>Identity and RBAC post created</done>
</task>

<task type="auto">
  <name>Task 5: Create "Building Secure Agent Workflows" post</name>
  <files>apps/www/_blog/2026-01-10-building-secure-agent-workflows.mdx</files>
  <action>
Create the engineering post at apps/www/_blog/2026-01-10-building-secure-agent-workflows.mdx:

```mdx
---
title: 'Building Secure Agent Workflows'
description: 'Engineering patterns for designing agent workflows with security built in from the start.'
author: axite_team
image: axite/placeholder-og.png
thumb: axite/placeholder-thumb.png
categories:
  - engineering
tags:
  - architecture
  - security
  - workflows
date: '2026-01-10'
toc_depth: 3
---

Security cannot be bolted on after the fact. This post covers engineering patterns for building agent workflows that are secure by design.

## The Workflow Security Challenge

Agent workflows often involve:

- Multiple agents collaborating on a task
- Sensitive data flowing between steps
- External API calls and integrations
- Human approval checkpoints

Each step is a potential security boundary that needs protection.

## Pattern 1: Gateway-First Architecture

Route all agent actions through Axite before they reach their destination:

```
Agent → Axite Gateway → Tool/API
         ↓
    Policy Evaluation
         ↓
    Audit Logging
```

This ensures no action bypasses governance, regardless of how the agent is implemented.

### Implementation

```typescript
// Instead of direct API calls
const response = await fetch('https://api.example.com/data')

// Route through Axite
const response = await axite.request({
  tool: 'http_request',
  params: {
    url: 'https://api.example.com/data',
    method: 'GET'
  }
})
```

## Pattern 2: Approval Workflows

For high-risk actions, require human approval before execution:

```typescript
const approvalWorkflow = {
  trigger: {
    action: 'send_email',
    conditions: [
      { field: 'recipients.count', greaterThan: 100 }
    ]
  },
  approval: {
    required: 2,  // Two approvers needed
    timeout: '4h',
    escalation: 'manager'
  }
}
```

The agent pauses, the approval request is sent, and execution continues only after approval.

## Pattern 3: Data Classification

Tag sensitive data and enforce handling rules:

```typescript
const dataClassification = {
  pii: {
    patterns: ['ssn', 'social_security', 'date_of_birth'],
    rules: [
      { action: 'deny', unless: { agent: { role: 'hr-agent' } } },
      { action: 'log', level: 'sensitive' }
    ]
  },
  financial: {
    patterns: ['account_number', 'routing_number', 'credit_card'],
    rules: [
      { action: 'require_approval', always: true },
      { action: 'encrypt', inTransit: true }
    ]
  }
}
```

## Pattern 4: Blast Radius Limits

Prevent runaway agents with rate limits and scope restrictions:

```typescript
const blastRadiusLimits = {
  agentId: 'data-processor',
  limits: {
    actionsPerMinute: 100,
    deletesPerHour: 10,
    externalCallsPerDay: 1000
  },
  onLimitReached: 'pause_and_alert'
}
```

## Pattern 5: Secure Handoffs

When agents pass work to each other, maintain security context:

```typescript
const handoff = axite.createHandoff({
  from: 'research-agent',
  to: 'writing-agent',
  data: researchResults,
  permissions: 'inherit_limited',  // Only pass necessary permissions
  audit: true
})
```

<Admonition type="note">
  Handoff audit logs create a complete chain of custody for multi-agent workflows.
</Admonition>

## Putting It Together

A secure agent workflow combines these patterns:

1. All actions through the gateway
2. Approval for high-risk operations
3. Data classification and handling rules
4. Rate limits and blast radius controls
5. Secure handoffs between agents

The result is a workflow where security is built in, not added on.

## Further Reading

- [Policy Enforcement](/blog/policy-enforcement-for-ai-agents) - Deep dive on policies
- [Identity and RBAC](/blog/identity-and-rbac-for-agent-systems) - Agent identity management
- [Audit Logs](/docs/audit) - Complete audit trail documentation
```
  </action>
  <verify>
Run: `head -15 apps/www/_blog/2026-01-10-building-secure-agent-workflows.mdx`
Verify: Frontmatter is valid with engineering category
Run: `grep "workflow" apps/www/_blog/2026-01-10-building-secure-agent-workflows.mdx`
Verify: Workflow content present
  </verify>
  <done>Secure workflows engineering post created</done>
</task>

</tasks>

<verification>
1. 5 new MDX files exist in apps/www/_blog/
2. All files have valid frontmatter with required fields
3. All files reference axite_team author
4. All files use placeholder images
5. Categories are valid (product, developers, engineering)
6. No MDX syntax errors (JSX-compliant tags)
</verification>

<success_criteria>
- 5 Axite blog posts created
- All posts have valid frontmatter
- All posts use axite_team author
- Posts cover overview and policy pillars
- No MDX syntax errors
</success_criteria>

<output>
After completion, create `.planning/phases/11-blog-compatibility/11-04-SUMMARY.md`
</output>
