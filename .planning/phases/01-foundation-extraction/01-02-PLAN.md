---
phase: 01-foundation-extraction
plan: 02
type: execute
wave: 2
depends_on: ["01-01"]
files_modified:
  - apps/www/package.json
  - packages/*/package.json
  - pnpm-workspace.yaml
  - scripts/convert-protocols.mjs
autonomous: true

must_haves:
  truths:
    - "pnpm install completes without protocol resolution errors"
    - "All workspace:* references converted to file: protocol"
    - "All catalog: references converted to explicit semver versions"
  artifacts:
    - path: "apps/www/package.json"
      provides: "Converted dependency declarations"
      contains: "file:../../packages/"
    - path: "pnpm-lock.yaml"
      provides: "Lockfile proving successful install"
  key_links:
    - from: "apps/www/package.json"
      to: "packages/*"
      via: "file: protocol dependencies"
      pattern: "file:\\.\\./"
---

<objective>
Convert all pnpm workspace:* and catalog: protocol references to standard formats, then verify pnpm install succeeds.

Purpose: The extracted Supabase code uses pnpm's special protocols that only work within their monorepo. Converting these protocols makes the project installable as a standalone workspace.

Output: All package.json files with converted dependencies; successful pnpm install with lockfile generated.
</objective>

<execution_context>
@~/.claude/get-shit-done/workflows/execute-plan.md
@~/.claude/get-shit-done/templates/summary.md
</execution_context>

<context>
@.planning/PROJECT.md
@.planning/ROADMAP.md
@.planning/STATE.md
@.planning/phases/01-foundation-extraction/01-CONTEXT.md
@.planning/phases/01-foundation-extraction/01-RESEARCH.md
@.planning/phases/01-foundation-extraction/01-01-SUMMARY.md
</context>

<tasks>

<task type="auto">
  <name>Task 1: Create and run protocol conversion script</name>
  <files>
    scripts/convert-protocols.mjs
    apps/www/package.json
    packages/*/package.json
    package.json
  </files>
  <action>
Create a Node.js ESM script to convert all protocol references. The script must:

1. Parse pnpm-workspace.yaml to extract catalog: version mappings
2. Find all package.json files in the project (excluding node_modules)
3. For each package.json:
   - Convert `catalog:` and `catalog:default` to the actual semver from pnpm-workspace.yaml
   - Convert `workspace:*` and `workspace:^` to `file:` relative paths
   - Remove `preinstall` scripts that enforce package manager (only-allow pnpm)

Create the script at `scripts/convert-protocols.mjs`:

```javascript
import { readFileSync, writeFileSync, readdirSync, statSync } from 'fs';
import { join, dirname, relative } from 'path';
import { parse } from 'yaml';
import { fileURLToPath } from 'url';

const __dirname = dirname(fileURLToPath(import.meta.url));
const rootDir = join(__dirname, '..');

// Load catalog versions from pnpm-workspace.yaml
const workspaceContent = readFileSync(join(rootDir, 'pnpm-workspace.yaml'), 'utf8');
const workspace = parse(workspaceContent);
const catalog = workspace.catalog || {};
const catalogs = workspace.catalogs || {};

console.log('Loaded catalog with', Object.keys(catalog).length, 'entries');

// Find all package.json files
function findPackageJsons(dir, results = []) {
  const entries = readdirSync(dir, { withFileTypes: true });
  for (const entry of entries) {
    const fullPath = join(dir, entry.name);
    if (entry.isDirectory() && entry.name !== 'node_modules' && entry.name !== '.git') {
      findPackageJsons(fullPath, results);
    } else if (entry.name === 'package.json') {
      results.push(fullPath);
    }
  }
  return results;
}

// Build package directory map for file: resolution
function buildPackageMap(packagesDir) {
  const map = {};
  try {
    const packages = readdirSync(packagesDir, { withFileTypes: true });
    for (const pkg of packages) {
      if (pkg.isDirectory()) {
        const pkgJsonPath = join(packagesDir, pkg.name, 'package.json');
        try {
          const pkgJson = JSON.parse(readFileSync(pkgJsonPath, 'utf8'));
          map[pkgJson.name] = pkg.name; // @supabase/ui -> ui
          map[pkg.name] = pkg.name; // ui -> ui
        } catch (e) {
          // Skip packages without package.json
        }
      }
    }
  } catch (e) {
    console.warn('Could not read packages directory:', e.message);
  }
  return map;
}

const packageMap = buildPackageMap(join(rootDir, 'packages'));
console.log('Found packages:', Object.keys(packageMap).join(', '));

// Transform a single package.json
function transformPackageJson(filePath) {
  const content = readFileSync(filePath, 'utf8');
  const pkg = JSON.parse(content);
  let modified = false;

  const pkgDir = dirname(filePath);
  const relativeToPackages = relative(pkgDir, join(rootDir, 'packages'));

  // Remove preinstall scripts that enforce pnpm
  if (pkg.scripts?.preinstall?.includes('only-allow')) {
    delete pkg.scripts.preinstall;
    modified = true;
    console.log(`  Removed preinstall script from ${filePath}`);
  }

  // Transform dependencies
  for (const depType of ['dependencies', 'devDependencies', 'peerDependencies']) {
    if (!pkg[depType]) continue;

    for (const [name, version] of Object.entries(pkg[depType])) {
      // Handle catalog: protocol
      if (version === 'catalog:' || version === 'catalog:default') {
        if (catalog[name]) {
          pkg[depType][name] = catalog[name];
          modified = true;
          console.log(`  ${name}: catalog: -> ${catalog[name]}`);
        } else {
          console.warn(`  WARNING: No catalog entry for ${name}`);
        }
      }
      // Handle named catalogs (catalog:name)
      else if (version.startsWith('catalog:') && version !== 'catalog:') {
        const catalogName = version.replace('catalog:', '');
        if (catalogs[catalogName]?.[name]) {
          pkg[depType][name] = catalogs[catalogName][name];
          modified = true;
          console.log(`  ${name}: ${version} -> ${catalogs[catalogName][name]}`);
        } else if (catalog[name]) {
          // Fall back to default catalog
          pkg[depType][name] = catalog[name];
          modified = true;
          console.log(`  ${name}: ${version} -> ${catalog[name]} (fallback)`);
        } else {
          console.warn(`  WARNING: No catalog entry for ${name} in ${catalogName}`);
        }
      }
      // Handle workspace: protocol
      else if (version.startsWith('workspace:')) {
        // Find the package directory
        const pkgDirName = packageMap[name];
        if (pkgDirName) {
          const relativePath = `${relativeToPackages}/${pkgDirName}`;
          pkg[depType][name] = `file:${relativePath}`;
          modified = true;
          console.log(`  ${name}: workspace:* -> file:${relativePath}`);
        } else {
          console.warn(`  WARNING: Unknown workspace package ${name}`);
        }
      }
    }
  }

  if (modified) {
    writeFileSync(filePath, JSON.stringify(pkg, null, 2) + '\n');
    console.log(`Updated: ${filePath}`);
  }

  return modified;
}

// Main execution
console.log('\\nScanning for package.json files...');
const packageJsons = findPackageJsons(rootDir);
console.log(`Found ${packageJsons.length} package.json files\\n`);

let modifiedCount = 0;
for (const pkgPath of packageJsons) {
  console.log(`Processing: ${pkgPath}`);
  if (transformPackageJson(pkgPath)) {
    modifiedCount++;
  }
}

console.log(`\\nDone! Modified ${modifiedCount} package.json files.`);
```

Install yaml parser dependency at root (needed for script):
```bash
pnpm add -D yaml --ignore-workspace
```

Wait, we can't run pnpm yet. Instead, use Node's built-in YAML parsing or a simpler approach:

Actually, use a simpler approach - write the script to handle YAML manually since it's a simple format:

```javascript
// Simpler YAML parsing for the catalog section
function parseSimpleYaml(content) {
  const lines = content.split('\\n');
  const catalog = {};
  let inCatalog = false;

  for (const line of lines) {
    if (line.trim() === 'catalog:') {
      inCatalog = true;
      continue;
    }
    if (inCatalog) {
      if (line.startsWith('  ') && line.includes(':')) {
        const match = line.match(/^\\s+(['"@\\w\\/-]+)['":]?:\\s*['\"]?([^'"\\s]+)['\"]?/);
        if (match) {
          const [, pkg, version] = match;
          catalog[pkg.replace(/['"]/g, '')] = version;
        }
      } else if (!line.startsWith(' ') && line.trim()) {
        inCatalog = false; // End of catalog section
      }
    }
  }
  return catalog;
}
```

Run the script:
```bash
node scripts/convert-protocols.mjs
```

After running, delete the script (one-time use per CONTEXT.md):
```bash
rm scripts/convert-protocols.mjs
rmdir scripts 2>/dev/null || true
```
  </action>
  <verify>
```bash
# Check that workspace: references are gone
grep -r "workspace:" apps/www/package.json packages/*/package.json 2>/dev/null || echo "No workspace: references found (good)"

# Check that catalog: references are gone
grep -r '"catalog:' apps/www/package.json packages/*/package.json 2>/dev/null || echo "No catalog: references found (good)"

# Check that file: references are present
grep -c "file:" apps/www/package.json
```
  </verify>
  <done>
- No workspace:* references remain in any package.json
- No catalog: references remain in any package.json
- apps/www/package.json contains file:../../packages/* references for internal deps
  </done>
</task>

<task type="auto">
  <name>Task 2: Run pnpm install and verify success</name>
  <files>
    pnpm-lock.yaml
    node_modules/**
  </files>
  <action>
Run pnpm install to verify all dependency protocols resolve correctly.

First, ensure pnpm-workspace.yaml is valid (it should already be from the copy):
```bash
cat pnpm-workspace.yaml
```

Should contain:
```yaml
packages:
  - 'apps/*'
  - 'packages/*'
```

If catalog: section exists, it's fine to keep - pnpm will ignore it since we've resolved all references.

Run the install:
```bash
pnpm install
```

Expected behavior:
- Should NOT error on "workspace:* could not be resolved"
- Should NOT error on "catalog: could not be resolved"
- May have peer dependency warnings (acceptable for now)
- May have deprecation warnings (acceptable)

If install fails on protocol errors:
1. Check which package.json still has the protocol
2. Re-run or manually fix the conversion
3. Try install again

If install fails on other errors (network, registry):
- Retry with `pnpm install --prefer-offline` if packages are cached
- Check npm registry connectivity
  </action>
  <verify>
```bash
# Lockfile should exist
ls -la pnpm-lock.yaml

# node_modules should exist in workspace roots
ls -la node_modules/
ls -la apps/www/node_modules/ 2>/dev/null || echo "www uses hoisted deps (expected)"

# Test that TypeScript can at least parse
cd apps/www && npx tsc --noEmit --skipLibCheck 2>&1 | head -20 || true
```

Note: TypeScript errors are acceptable at this stage - we just need pnpm install to succeed without protocol errors.
  </verify>
  <done>
- pnpm install completes without protocol resolution errors
- pnpm-lock.yaml is generated
- node_modules exists at project root
  </done>
</task>

</tasks>

<verification>
After both tasks complete:

1. Protocol conversion complete:
```bash
# Should return nothing or only legitimate workspace config
grep -r "workspace:" . --include="package.json" | grep -v node_modules | grep -v "pnpm-workspace" || echo "Clean"
grep -r '"catalog:' . --include="package.json" | grep -v node_modules || echo "Clean"
```

2. Install succeeded:
```bash
ls -la pnpm-lock.yaml
pnpm ls --depth 0 2>/dev/null | head -10
```

3. Phase 1 complete check:
```bash
echo "=== Phase 1 Verification ==="
echo "1. www source exists:"
ls apps/www/package.json && echo "   PASS" || echo "   FAIL"
echo "2. workspace:* resolved:"
grep -q "workspace:" apps/www/package.json && echo "   FAIL" || echo "   PASS"
echo "3. catalog: resolved:"
grep -q '"catalog:' apps/www/package.json && echo "   FAIL" || echo "   PASS"
echo "4. pnpm install succeeded:"
ls pnpm-lock.yaml && echo "   PASS" || echo "   FAIL"
```
</verification>

<success_criteria>
- pnpm install completes without "workspace:* could not be resolved" errors
- pnpm install completes without "catalog: could not be resolved" errors
- pnpm-lock.yaml exists at project root
- apps/www/package.json contains `file:` references for internal packages (not workspace:*)
</success_criteria>

<output>
After completion, create `.planning/phases/01-foundation-extraction/01-02-SUMMARY.md`
</output>
